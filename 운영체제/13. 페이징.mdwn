# 분산 메모리 할당

- 비연속 메모리 할당이라고 함 혹은 불연속 메모리 할당
- 대표적으로는 페이지와 세그멘테이션으로 나뉨

# 페이징

- 프로제스를 크기가 고정된 여러 페이지로 나누고 메인 메모리의 빈 프레임에 적재함
- 이 과정에서 2가지 용어가 등장 (프레임, 페이지)
  - 프레임 : 메인 메모리에 페이지를 적재하는 공간
  - 페이지 : 작업을 나눈 단위
- Address Binding 관점
  - 연속 할당 기법에서는 MMU 가 동작하였다면 페이지에서는 Page Table 이 동작함
    - MMU 는 페이지 테이블을 보고 논리 주소를 물리 주소로 변환
- 단편화의 관점
  - 빈 프레임에는 어떤 페이지던 적재할 수 있기 때문에 외부 단편화를 막음
    - 하지만 내부 단편화는 발생가능
  - 내부 단편화를 막기 위해서는 페이지의 크기를 작게하면 됨
    - 하지만 프레임에 페이지를 자주 적재해야 하니까 운영체제의 부담이 큼

# 페이지 테이블

- 페이지 맵 테이블, PMT 라고도 함
  - 페이징에서 논리 주소를 물리 주소로 변환하기 위해 참고하는 메모리 공간
  - PMT를 레지스터에 저장하기도 하고 메인 메모리에 저장하기도 함
    - 레지스터는 구현하기 쉬운데 효율이 안나옴. 그리고 일반적인 페이지 테이블의 크기는 너무 커서 불가능
  - 하지만 PMT 자체가 비효율적이다는 의견이 있음, 프로세스 하나당 하나의 PMT를 생성해야 하므로
  - 그래서 보통 PTBR, Page Table Base Register 인 페이지 테이블 기준 레지스터로 페이지 테이블을 가리키게 함
    - 이것 조차도 느리다는 말이 있어서 뒤에 나올 TLB를 두기도 함
- 프로세스가 만드는 논리적 주소는 **페이지 번호와 오프셋**으로 구성됨
  - **페이지 번호** `p` 는 페이지 번호로 PMT의 인덱스
  - **기준 주소** `f` 는 `p` 즉 페이지 번호에 저장되어있는 페이지 기준 주소로 메인 프레임의 번호임
  - **오프셋** `d` 는 페이지 프레임의 위치를 표시하는 상대 주소
- 물리적 주소를 얻는 방법
  - **오프셋** `d` 와 **기준 주소** `f` 를 더하면 물리 주소를 얻을 수 있음

# 논리 주소 변환

- 페이지 하나의 크기와 특정 논리 주소를 알고 있다면 전체 페이지 크기를 알 수 있다.
  - 페이지 하나가 `2^n` 이라면 논리 주소의 n자리까지는 오프셋 상위는 페이지 번호가 됨
  - ex) 페이지 하나가 8B 이고 논리 주소가 `101101(2)` 일 때, 물리적 주소를 구하라
    - 페이지 하나는 `2^3` 이므로 3자리에서 끊음.
    - 그럼 페이지 번호가 101(2) 인 5가 됨
    - 오프셋 번호는 101(2)인 5가 됨
    - 페이지 테이블 5번째를 찾으면 물리적 페이지가 나옴
    - `((물리적 페이지 * 페이지 하나의 크기) + 오프셋)`을 하면 물리적 주소가 나옴

# 다중 단계 페이징 시스템

- 논리적 주소가 클수록 물리적 주소로 변환하는 과정에서 필요한 테이블의 크기도 증가
  - 메모리가 더 많이 필요
- 32Bit 프로세서에서 4KB 페이지를 위한 페이징의 하위 12bit 는 오프셋이고 상위 20bit 는 페이지 번호이므로 2^20 새의 페이지 정보가 필요하고 그만큼 페이지 테이블의 크기가 늘어남
  - 이 과정에서 페이지 정보를 나누어 생성하면 필요없는 페이지는 없애고 공간 절약이 가능
  - 사용하지 않는 페이지는 주소값을 생성하지 않고, 필요한 페이지의 주소정보만 생성하여 관리하는 시스템
  - 중간에 페이지 디렉토리를 두고 필요한 부분만 페이지로 나누어서 페이지 테이블에 두고 사용하는 방식
    - 이 과정에서 CR3 Register
- CR3 Register
  - 해당 레지스터가 디렉터리의 BaseAddress 로 접근하여 페이지 디렉토리 정보를 찾아서 페이지 테이블로 접근하여 물리주소를 구함

# TLB

- 변환 우선참조 버퍼
- TLB(Translation Lookaside Buffer) 를 두어서 캐싱을 함
  - 최근 물리주소로 변환된 가상주소를 저장하는 보조하드웨어장치
  - 테이블 조회 결과를 TLB에 저장하고 다시 쓰인다면 해당 정보를 토대로 작업

# 연관 레지스터를 이용한 Address Binding 방법 3가지, 캐싱

- 직접 매핑으로 변환
  - 메모리나 캐시에 완전한 페이지 테이블을 유지 -> 메모리 주소와 캐시의 순서를 일치시킴
  - 구현 규칙을 만족하기 위해서 캐시를 자주 교체해야함
  - 적중률이 낮고 단순함
- 연관 매핑으로 변환
  - 순서를 일치시키지 않고 메모리 값을 캐시의 어디에나 저장함 -> 당연히 메모리 주소를 찾는 과정이 복잡하고 느림
  - 논리적 주소를 프로세서의 페이지 번호와 메모리의 프레임 번호가 있는 연관 레지스터의 집합으로 표현
  - 적중률이 높고 하드웨어가 매우 비쌈
  - 캐시는 빠르기떄문에 검색량을 신경쓰는 것 보다 적중률을 높게하는 것이 더 좋지만 비쌈
- 연과 + 직접 매핑으로 변환
  - 연관의 장점과 직접의 장점을 적절히 혼합
  - 순서를 일치시키되(직접), 일정 그룹을 두어 그룹 내에서 편하게 저장시킴(연관)

# 공유 페이지

- 프로세스끼리 가져야하는 공통 코드, 데이터가 있다면 이를 서로 공유할 수 있도록 함
  - 하지만 동기화가 발생할 수 있으므로 읽기 전용으로 구성함
- 동일한 논리 주소의 순서여야 공유 페이지 가능? -> 모름

# 페이징의 보호

- 특정 프로세스가 다른 프로세스의 페이지 범위를 침범하는 것을 방지
  - 페이지 테이블 보호 비트를 사용하여 침입 방지
  - 타당, 비타당 비트로 나눔
