# 메모리 관리

- 메모리 관리의 이유
  - 현대의 프로그램은 우선 메모리에 적재 후 여러 프로세스를 돌리는데, 한정된 메모리를 여러 프로세스가 사용하기 위해서 효율적인 관리가 필요하기 때문에
- 메모리 관리란?
  - 프로세스들을 위해서 메모리를 할당하고 제거하며 보호하는 활동
  - 프로세스의 요청에 따라 메모리를 할당하고 해제하는 과정
  - 프로그램을 실행하기 전에 메모리를 적재하는 것도 포함
- 메모리 관리는 메모리 관리자가 담당하는데, 운영체제의 관리 모듈과 MMU, Memory Management Unit 이 서로 협업하여 관리
- 메모리 관리의 3가지 정책이 있음
  1. 적재 정책, fetch policy : 디스크 -> 메모리 반입
  2. 배치 정책, placement policy : 반입한 프로세스를 어디에 위치시킬 것인가
  3. 대치 정책, replacement policy : 메모리가 충분하지 않을 때 어떻게 교체할 것인가

# 메모리의 구조와 매핑

- 메모리 : 주소 공간의 연속으로 물리적 주소를 다루기 위해 사용자는 논리적 주소를 이용하고 MMU가 Address Binding 수행
  - 물리적 주소
    - 메모리 Unit 의 실제 주소
    - 사용자가 접근 불가
    - 논리 주소에 매핑된 실제 주소 집합
  - 논리적 주소
    - CPU가 생성한 가상 주소
    - 사용자가 접근 가능
    - 논리 주소를 이용해서 논리 주소로 접근
    - 고수준 언어에서의 변수를 생성하는 것
  - 주소 바인딩
    - Address Binding 혹은 Mapping
    - MMU가 처리 (고정 분할, 동적 분할, 페이징, 세그멘테이션, Paged 세그멘테이션 방법 적용)

# 바인딩 분류

- 논리적 주소를 물리적 주소로 변환하는 시점(Time)에 따라 용어를 나눌 수 있음
  - 컴파일 시간, 적재 시간, 실행 시간으로 구분가능
- 바인딩 타임 (Binding Time)
  - Language Implementation Time
    - 언어에서 허용되는 자료구조나 프로그램 구조를 확정
  - Language Definition Time
    - 언어를 정의할 때 int나 char 등의 키워드를 문법대로 자르는 것(Lexing)
  - Compile Time
    - 컴파일 할 시점에 물리 주소를 생성, Data, Stack 등 메모리에 들어갈 변수가 정해짐
  - Link Time
    - 프로그램과 라이브러리가 링크될 때 물리 주소를 생성, 변환
  - Load Time
    - 변수를 메모리로 적재할 때 주소가 결정
  - Run Time
    - 프로그램을 실행할 때 변수의 값을 확정
    - 경계 레지스터나 기본 레지스터 등의 특수 하드웨어 지원이 필요
    - 현재 범용 운영체제 대부분은 실행 시간에 바인딩하는 이 방법을 사용

# 메모리 관리 용어

- 동적 적재
  - 바인딩을 최대한 늦춰 실행 직전에 주소를 확정하여 메모리를 효율적으로 운영
  - 모든 루틴을 메모리에 적재하지 않고 교체 가능한 형태로 디스크에 저장
  - 만약 적재되어 있지 않다면 루틴을 적재하기 위해서 주소 테이블을 갱신
  - 프로그램 전체 양이 많을 때 더 유용
- 중첩 (오버레이)
  - 실행하려는 프로그램이 메모리보다 클 때 당장 필요하지 않은 프로그램의 일부를 중접(오버레이)로 설정할 수 있음
  - 공통 루틴과 중첩 영역으로 나누고 공통 영역에는 실행에 꼭 필요한 명령어와 데이터만 저장
  - 현대 프로그램은 크기가 커져 이해하기가 어려워서 마이크로 컴퓨터나 메모리가 제한된 하드웨어에서만 사용
- 스와핑
  - 스왑 인과 스왑 아웃을 수행해서 프로세스를 교체
  - Swap-Out 프로세서 할당이 끝나고 수행이 완료된 프로세스는 보조기억장치로 보냄
  - Swap-In 새롭게 프로세스는 메모리에 적재

# 프로세스 스와핑 과정

- 중단 상태가 포함된 프로세스 상태 변화에서 등장하는 스왑
- 중기 스케줄러(메모리에 적재된 프로세스 수 관리)가 참여
  - 디스크에 저장된 프로세스를 메모리로 옮기고 메모리에 적재된 프로세스를 Ready Queue 에 대기하도록 하는 과정
  - 순서
    1. 스와핑 대상이 된다면 단기 스케줄러에 의해 wait 상태로 변경
    2. 실행 조건을 만족하면 Ready Queue 로 이동하거나 디스크로 Swap-Out
    3. 스왑 아웃
- 준비에서 ready-wait, suspend-wait
- 스와핑은 초기 시분할에서 채택했는데 최근에 페이지로 발전함

# 메모리 적재 방법, 관리 기법

- 메모리를 적재하는 방법 혹은 관리 기법은 크게 2가지로 나뉨 (메모리 연속적 적재, 페이지나 세그먼트 단위로 나눠 여러 곳에 적재하는 비연속)
  - 연속 적재, Continuous Allocation
    - 초기 프로그램이 메모리를 적재하는 방법
    - 연속된 하나의 블록을 하나의 프로그램이 차지
    - 직접 배치, 중첩, 고정 분할 방법등
    - 메모리 낭비가 발생할 수 있음
  - 비연속 적재 (분산 메모리 할당), Noncontinuous Allocation
    - 연속 적재의 외부 단편화를 해결하고 내부 단편화를 최소화 하려고 탄생
    - 페이지나 세그먼트 단위로 구분
      - 고정 분할 : 페이징
      - 가변 분할 : 세그먼테이션
