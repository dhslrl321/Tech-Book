# 스케줄링 알고리즘

- 단기 스케줄러가 디스패치에게 할당하기 전에 어떤 알고리즘으로 프로세서를 할당할지 결정하는 방법
- 스케줄링 알고리즘에 대해서는 선점과 비선점에 대해서 알아야 함
  - 선점 (Preemtive) : 현재 실행 중인 프로세스를 인터럽트할 수 있거나 준비 상태로 이동시킬 수 있음
    - 프로세스 하나가 장시간동안 프로세서를 독점하는 것을 방지
    - 긴급 처리에 유용하나 응답 시간을 예측하기 어려움
    - 많은 프로세스가 준비 상태여야 하기 때문에 오버헤드가 커질 수 있음
  - 비선점 (Non-Preemtive) : 프로세스가 자원을 이용할 때 다른 프로세스가 해당 자원을 사용하기 위해 전 프로세스를 중단시킬 수 없음
    - 모든 프로세서를 공정하게 관리함
    - 응답 시간을 예측하기 쉬움

# 알고리즘 구분

- 선점 vs 비선점으로 구분 가능
  - 선점
    - Round-Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐
  - 비선점
    - FCFS, SJF, HRN 우선순위, 기한부

# 알고리즘 평가

- 알고리즘을 선정하기 위해서 사용하는 다양한 지표들이 있음
- 프로세서 사용률 : 프로세서를 항상 실행 상태로 유지
- 처리율 : 단위시간당 완료하는 작업 수가 많도록 작업을 실행
- **Response Time, 반환시간** : 작업이 메모리에 들어가기까지 걸린 시간, 준비 큐에 머무는 시간, 실행 시간, 입출력 시간등 작업을 완료하는데 걸린 시간
- **Turnaround Time, 반응시간** : 작업을 요청한 시간부터 반응을 시작하는 시간 (대화형 시스템에서 사용)
- **대기시간** : 준비 큐에서 기다리는 시간

# FCFS, First Come First Served

- 선입선처리 알고리즘
- 가장 단순한 스케줄링 알고리즘
- 선점 알고리즘 답게 일괄처리에서는 효과적이나 대화식에서는 비효율적
- 새로운 프로세스가 들어오면 PCB 를 준비 큐의 마지막에 연결
- 큰 프로세스 하나를 처리하기 위해서 다른 프로세스들은 대기함
- 장점과 단점
  - 장점
    - 스케줄링의 이해와 구현이 단순함
    - 준비 큐에 있는 모든 프로세스가 결국 실행되므로 공정한 정책
  - 단점
    - 비선점방식이므로 대화식에는 비효율
    - 장기 실행 프로세스가 뒤의 프로세스를 모두 지연시켜 평균 대기시간이 길어지면 최악의 대기시간이 됨
    - 프로세서 중심 프로세스 하나가 프로세서를 떠나기 기다리는 현상인 (Convoy Effect) 호위 효과가 발생한다.

# SJF, Shortest Job First

- 최소 시간 우선 알고리즘
- 실행 시간이 가장 짧은 작업 먼저 할당하는 방법
- 만약 프로세서 실행 시간이 동일하다면 FCFS 알고리즘을 적용
- 프로세서 버스트 시간을 비교하여 큐에서 위치를 결정
- 선점 방식과 비선점 방식이 모두 가능함 (선점은 SRTF, 비선점은 SJF)

# SRTF, Shortest Remaining Time First

- 최소잔여 시간 우선 알고리즘
- 프로세스가 들어올 때의 최소 시간을 매번 갱신해서 점유시킴
- 선점 알고리즘
- 선점에는 Context Switching 의 시간이 필요하므로 무조건 유리하지는 않음
- 장점과 단점
  - 장점
    - 항상 실행 시간이 짧은 작업을 신속하게 실행하므로 평균 대기시간이 가장 짧음
  - 단점
    - 실행 시간을 예측하기가 어려워 실용적이지 않음
    - 초기의 긴 작업을 짧은 작업을 종료할 때까지 대기시켜 기아가 발생

# Priority

- 우선순위 알고리즘
- 정적/동적으로 우선순위를 부여하여 우선순위가 높은대로 처리
- 우선순위의 요소로는 제한 시간, 평균 프로세서 버스트 등이 있음
- 선점 또는 비선점 모두 가능하다
- 우선순위에서 위험한게 무한 정지와 기아상태(Starvation)임.
  - 이를 해결하는 방법을 에이징(Aging)이라고 함
  - 에이징 : 시스템에서 오래 대기하는 프로세스들의 우선순위를 점진적으로 증가시켜줌
- 장점과 단점
  - 장점
    - 각 프로세스의 상대적 중요성을 정확히 알 수 있다.
    - 다양한 반응으로 실시간 시스템에서 자주 사용될 수 있다.
  - 단점
    - 높은 우선순위 프로세스가 프로세서를 많이 점유하면 우선순위가 낮은 프로세스는 무한정 대기의 기아상태가 발생할 수 있다.

# RR, Round Robin

- 라운드로빈 스케줄링
- 준비 큐(Ready Queue)를 순환 큐(Circular Queue)로 설계하여 스케줄러가 준비 큐를 돌아가면서 한 번에 한 프로세스에 규정된 시간만큼 할당
  - 준비 큐는 FIFO 큐로 구성되어 있어서 새로운 프로세스를 추가할 떄는 큐 tail 에 추가시킴
- 할당된 시간 (Time Quantum, Time Slice)이 끝나면 프로세스를 Queue 의 tail 에 추가함
- 할당 시간을 잘 정의하는게 중요함
  - 할당 시간을 크게 할 경우 : FCFS 와 같아짐
  - 할당 시간을 작게 할 경우 : Context Switching 이 잦아져서 오버헤드가 증가함
- 장점과 단점
  - 장점
    - 모든 프로세스가 동일한 시간을 점유하기 때문에 Starvation 이 발생하지 않는다.
  - 단점
    - Interupt Clock 을 위한 하드웨어 타이머가 필요함
    - 미완성 작업은 각 규정 시간량을 마친 후 프로세서를 대기하니까 평균 처리 시간이 높다.

# Multilevel Queue

- 다단계 큐 스케줄링
- 각 작업을 서로 다른 그룹으로 나누어 여러 개의 큐를 사용함
  - 또한 각 큐에서도 절대적 우선순위가 존재함
  - ex) 포어드라운드, 백그라운드 프로세스는 응답 시간과 요구 사항이 다르기 때문에 잘 맞는 스케줄링 알고리즘이 있음 -> 포어그라운드는 포어그라운드 끼리 하나의 큐로 관리하고 백그라운드는 백그라운드 끼리 하나의 큐로 관리
- 우선순위가 높은 큐가 비어있기 전에는 낮은 우선순위 큐의 프로세스를 실행할 수 없다.
- 장점과 단점
  - 장점
    - 응답이 빠르다
  - 단점
    - 여러 준비 큐와 스케줄링 알고리즘 때문에 추가 오버헤드가 발생한다.
    - 우선순위가 낮은 큐의 프로세스는 Starvation 이 발생할 수 있다.

# Multilevel-Feedback-Queue

- 다단계 피드백 큐 스케줄링
- 다단계 큐 스케줄링에서는 하나의 프로세스는 하나의 큐에 거의 영구적으로 종속되어 관리되지어 융통성이 적음
- 다단계 피드백 큐 스케줄링은 서로 다른 큐로 프로세스 이동을 허용함
- 상위 우선순위 큐는 Time Quantum 이 존재하고 가장 하위 우선순위의 큐는 FCFS 스케줄링 알고리즘을 적용한 준비 큐
  - Time Quantum 이 다 채워졌음에도 불구하고 종료가 되지 않은 경우에는 아래 단계의 우선순위 큐로 이동
- 다단계 큐에서 우선순위를 매기고 Aging 을 추가하여 큐간 이동을 한 것이라고 보면 됨
  - 상위 큐가 높은 우선순위를 갖게 되므로 높은 큐에 enqueue 하는것 자체가 Aging 을 이용한 것이라 할 수 있음
- 여러 스케줄링을 이용한 것이라 가장 복잡한 알고리즘고 또한 모든 매개변수(우선순위를 결정할 수 있는 값)의 값을 선정하는 방법이 필요함
