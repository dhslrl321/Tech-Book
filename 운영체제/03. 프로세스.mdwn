# 프로세스

- 프로세스의 가장 잘 부합하는 의미
  - 디스크에 저장된 프로그램을 메인 메모리에 적재하여 운영체제의 제어를 받는 대상
- 다양한 프로세스 정의법
  - 실행 중인 프로그램
    - 프로그램 vs 실행 중인 프로그램
  - 실행 중인 프로시저
  - 운영체제에 들어있는 PCB
  - 프로세서에 할당해 디스패치가 가능한 대상
- 프로세스가 포괄하는 내용
  - 프로세서 점유 시간, 메모리, 파일, 입출력 장치 + 프로세스의 활동을 나타내는 것들(PC, Register)
- 프로세스 vs 프로그램
  - 프로그램 : 컴파일된 코드의 데이터 (전역 변수, 문자열, 상수) 의 정적 데이터를 포함하는 정적인 객체, passive entity
  - 프로세스 : 메모리 구조를 이루고 PC나 Register 처럼 현재 어떤 자원을 이용하는지 관련 정보가 들어있는 동적인 객체, 주소 공간을 가지고 실행하는 프로그램, active entity

# 프로세스의 메모리 구조

- 크게 기계여의 코드가 들어있는 **코드 영역**과 데이터를 저장하는 **데이터 영역**으로 나눌 수 있음
- 데이터 영역에서는 다시 **전역 메모리**, **스택**, **힙**으로 나눌 수 있음
  - 스택 : 데이터를 일시 저장하고 지역변수나 호출한 함수의 반환 주소, 매개변수 등이 존재
    - 함수 내에 저장된 지역변수들을 위한 공간으로 컴파일 시에 크기를 확정하므로 낭비되는 공간이 없이 최적화가 가능
    - 만약 스택 포인터와 힙 포인터가 만나게 된다면 메모리가 모두 소진되었음을 의미
  - 힙 : 코드 영역과 별도로 유지되는 자유 영역, 동적 메모리 할당 영역
    - 프로그램 실행 도중에 할당을 받을 수 있어서 유연성이 부족한 스택을 커버함
  - 전역 메모리(데이터) : 가상 주소 공간으로 전역 변수나 정적 변수를 저장
- 코드 : 실행 명령을 포함하는 메모리이거나 Object 파일에 있는 프로그램 영역
  - 프로세스는 하나의 코드 영역을 공유하더라도 서로 다른 스택, 힙, 데이터 세션을 가질 수 있음을 인지해야 한다.

# 프로세스 종류와 구분

- 역할에 따른 구분
  - 시스템(커널) 프로세스
  - 사용자 프로세스
- 병행 수행 방법에 따른 구분
  - 독립 프로세스 : 다른 프로세스에 영향을 주지 않거나 다른 프로세스의 영향을 받지 않음
  - 협력 프로세스 : 다른 프로세스에 영향을 주거나 다른 프로세스에게 영향을 받음

# 프로세스 상태 변화

- 프로세스는 크게 **실행 상태**와 **비실행 상태**로 나뉠 수 있음
  - 상태 세분화
    - 실행 상태 : (실행)
    - 비실행 상태 : (준비, 대기)
  - OS가 프로세스를 생성하면 프로세스를 비실행 상태로 초기화 해서 실행을 기다림 (준비)
  - 실행 중인 프로세스가 인터럽트 신호를 받으면 실행 상태에서 비실행 상태로 변경됨
- 이 상태 변화를 **프로세서 스케줄러**를 이용해서 OS는 관리함
- 프로세스 상태
  - 생성 : OS가 프로세스를 생성하고 초기화된 상황
  - 준비 : 실행을 대기하는 상황
  - 실행 : 프로세스가 프로세서를 점유하고 있는 상황, 만약 프로세서에게 할당된 시간이 다 되면 준비 상태로 변환될 수 있음
  - 대기 : 프로세스가 인터럽트를 받아 처리를 멈춘 상황, 대기 원인을 제거하면 다시 준비 상태로 변환 (프로세스 스스로 결정)
  - 종료 : 프로세스가 할 일을 모두 마친 상황
- 프로세스 상태 변화
  - 준비 -> 실행
    - Dispatch
    - 준비 큐 맨 앞에 있떤 프로세스가 프로세서를 점유하고 있는 상황
  - 실행 -> 준비
    - Timeout
    - 프로세스가 프로세서를 독점하지 않도록 하는 인터럽트 클록에 제어되어 실행에서 준비 상태가 되는 상황
  - 실행 -> 대기
    - Block
    - 실행 상태의 프로세스가 다른 외부의 연산 및 입출력이 필요할 때, 스스로가 다른 프로세스에게 프로세서를 양도하는 상황
  - 대기 -> 준비
    - Wake-Up
    - 대기 원인을 제거했을 때, 대기 상태에서 준비 상태로 되는 상황

# PCB, Process Control Block

- 특정 프로세스에 대한 중요한 정보(문맥 교환에 필요한 데이터 및 레지스터 및 다양한 정보)를 저장하고 있는 커널 내의 자료구조
- PCB에 저장되어있는 데이터 및 정보
  - 프로세스 식별자, PID
  - 프로세스 상태 : new ready running waiting terminated 등의 정보
  - 프로그램 카운터 : 프로세스가 다음에 실행시킬 명령어의 주소를 가리킴
  - 레지스터 저장 영역
  - 프로세서 스케줄링 정보 : 프로세스의 우선순위 및 스케줄 큐에 대한 포인터
  - 계정 정보
  - 입출력 상태 정보 및 메모리 관리 정보 ...
- PCB는 리눅스의 커널 소스코드 디렉토리의 [linux/sched.h](https://github.com/torvalds/linux/blob/master/include/linux/sched.h) 헤더 파일에 정의되어 있음

# 프로세스 중단과 재시작

- 기본적인 프로세스 상태(준비, 실행, 대기, 종료) 만 존재한다면 시스템의 유휴 시간이 증가하게 됨
  - 입출력 동작이 일반 연산보다 느린경우가 많아서 시스템이 놀고 있는 상황이 됨
  - 이 문제를 해결하기 위해서 **중단 상태**를 이용함
- 중단 상태 : 특정 이벤트가 발생해 프로세스가 대기가 되었을 때, 중단을 시켜서 바로 실행을 시킴

# Context Switching

- 프로세스가 다른 프로세스에게 프로세서 점유권을 넘겨주는 것
- 컨텍스트 스위칭이 일어나면 프로세서에 있는 데이터를 나중에 사용할 수 있도록 저장함
- 이 과정에서 PCB 내부의 데이터를 이용하여 프로세스의 진행 상황을 PCB에 저장

# 프로세스의 생성

- OS나 프로그램에서 요청을 받아 프로세스를 생성하면 PCB를 만들어 주소 공간을 할당받음
- fork 를 통해서 생성
- 생성 과정
  1. 프로세스에 PID를 부여
  2. PCB 생성 및 주소 공간 할당
  3. PCB 초기화
  4. 링크(Ready Queue 에 삽입)

# 프로세스 삭제

- 프로세스가 마지막 명령을 실행하고 종료되면 운영체제에 프로세스 삭제 요청을 하게되는것
- 자식 프로세스는 부모 프로세스가 종료될 때 함께 삭제되는데, 이를 연속 종료라고 함
