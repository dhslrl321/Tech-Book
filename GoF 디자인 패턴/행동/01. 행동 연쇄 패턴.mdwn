# 책임 연쇄 패턴

> 메시지를 보내는 객체와 이를 받아 처리하는 객체들 간의 결합도를 없애기 위한 패턴.
> 하나의 요청에 대한 처리가 반드시 한 객체에서만 되지 않고, 여러 객체에게 그 처리 기회를 줌

- 메시지 송신 측과 수신 측을 분리하는 것이 목적
  - 이를 위해 이 요청을 처리하는 기회를 다른 객체에게 분산시킴
  - 이 요청을 처리할 수 있는 객체가 등장할 때 까지 객체 연결 고리(Chain Of Responsibility)를 따라서 요청을 전달
  - 만약 특정 객체가 해당 요청을 수신할 수 있다고 한다면 자신에게 정의된 서비스 제공

# 등장 배경

# 참여 객체

- Handler
  - 요청을 처리하는 인터페이스를 정의하고 후속 처리자(successor)와 연결을 구현
  - 연결 고리에 연결된 다음 객체에게 다시 메시지를 보냄
- ConcreteHandler
  - 책임져야 할 행동이 있다면 스스로 요청을 처리
  - 만약 스스로가 책임지지 못한다면 후속 처리자(successor) 에게 다시 요청을 전달
- Client
  - ConcreateHandler 에게 필요한 요청을 보내는 역할

# 예시

- 비행기 기내에서 기내식을 찾는 손님이 여러 역할을 맡은 승무원들중 아무에게나 요청을 한다면 적절한 승무원이 기내식을 보내줌
- Handler
  - `InFlightServiceHandler`
- ConcreteHandler
  - `AirlineMealCrew`
  - `SafetyCrew`
  - `DutyFreeGoodsCrew`
- Client
  - `Passenger`

# 장점과 단점

### 장점

- 객체 간의 낮은 결합
  - 다른 객체가 어떻게 요청을 처리하는지 몰라도 새로운 객체의 구현이 가능하다.
- 책임 할당 유연성 증가
- 클라이언트는 처리객체의 집합 내부 구조를 몰라도 된다.

### 단점

- 메시지 수신이 보장되지 않는다.
- 디버깅 및 테스트가 쉽지 않다.

# 만약 패턴을 사용하지 않는다면?

- 패턴을 사용하지 않을 떄의 복잡성을 보여줌
- 그리고 이 복잡성을 어떻게 패턴으로 끄집어 내는지 보여줌
