# 컴포지트 패턴

> 부분(part)과 전체(whole) 관계를 표현하기 위한 객체를 모아 트리 구조로 구성하여 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴

- 기본 요소와 이들의 컨테이너를 모두 표현할 수 있는 하나의 추상화 클래스를 정의하는 것

# 등장 배경

- 하나의 컴포넌트가 다른 컴포넌트를 포함하고 해당 컴포넌트는 또 다른 컴포넌트에게 포함되는 트리 구조일 때
- 이를 구현하기 위해서는 기본 요소에 대한 클래스를 정의하고 이를 포함한 컨테이너로 동작하는 클래스를 추가로 정의
  - 이렇게 하면 각각의 컴포넌트에 대한 클래스를 정의해야 하고 컨테이너인지 컴포넌트인지 구분하는 코드를 작성해야 하는 문제

# 활용성

- 부분-전체의 객체를 표현하고 싶을 때
- 객체 합성으로 생긴 복합 객체와 개개의 객체 사이의 차이를 알지 않고도 자기 일을 할 수 있도록 만들고 싶을 때

# 참여 객체

- Component
  - 집합 관계에 정의될 모든 객체에 대한 인터페이스를 정의
- Leaf
  - 자식이 없는 객체, 가장 말단의 객체
- Composite
  - 자식이 있는 구성요소 객체
  - Component 인터페이스의 연산을 구현
- Client
  - Component 인터페이스를 통해 복합 구조 내의 객체를 조작

# 예시

- 여행객의 종류는 패키지 여행객, 일반 여행객, 비즈니스 여행객이 존재
  - 패키지 여행 :
  - 비즈니스 여행 : 출장을 위한 승객
- 입국 심사에서 패키지 여행은 여행 대표만 심사를 진행
- Component
  - `PassengerComponent`
- Leaf
  - `Passenger`
- Composite
  - `PackageTourPassengers`
  - `BusinessTripPassenger`
- Client
  - `Immigration`

# 장점과 단점

### 장점

- 기본 개체와 복합 객체로 구성된 하나의 일관된 클래스 계통을 정의할 수 있다.
- 기본 객체는 더 복잡한 객체들에 속해있을 수 있다.
- 복합 객체를 구분하지 않고 일관되게 프로그래밍할 수 있다.
- 사용자의 코드가 단순해진다.

### 단점

- 설계가 지나치게 범용성을 많이 가진다.
- 하나의 객체가 두 종류의 일을 수행해야 하므로 단일 역할의 원칙을 깬다.
- 새로운 요소를 쉽게 추가할 때 복합체의 구성요소에 제약을 가하기 힘들다
- 무의미한 연산이 포함될 수 있다.

# 결론

- 컴포지트 패턴은 단일 역할 원칙을 깨지만 투명성을 확보할 수 있는 패턴이다.
- 두 종류의 기능 (Passenger 가 리프 노드임에도 불구하고 add 를 수행하려 한다던가)을 수행하면서 안정성이 떨어질 수 있다.
- 하지만 이를 사용한다면 코드를 많이 줄일 수 있고, 투명성과 편의성을 챙길 수 있다.
- 프로젝트 스펙과 설계에 제약이 되지 않으면 컴포지트 패턴도 좋은 효과를 얻을 수 있다.
