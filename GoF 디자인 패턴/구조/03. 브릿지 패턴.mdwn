# 브릿지 패턴

> 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 한다.

- 기능과 구현에 대해서 두 개를 별도의 클래스로 구현
  - 기능 계층과 구현 계층 분리하기
    - 분리함으로 서로 다른 계층의 커플링을 약화시키며 협력
- 기능 계층 vs 구현 계층
  - 기능 계층 : A라는 상위 클래스를 상속받아 B라는 하위 클래스에서 새로운 기능을 추가하는 계층임
  - 구현 계층 : A라는 인터페이스를 구현한 B라는 객체가 존재할 때, 구현 클래스 계층이라고 함

# 패턴 등장 배경

- 하나의 추상적 개념이 여러 가지 구현으로 구체화될 수 있을 때는 대부분 상속을 이용
  - 추상 클래스로 추상적 개념에 대한 인터페이스 정의
  - 각 기능을 수행할 구체 클래스가 이 인터페이스를 구현
- 상속은 구현과 추상적 개념을 영구 종속시킴
  - 결국 확장성, 재사용성이 떨어짐

# 참여 객체

- Abstraction
  - 기능 계층의 최상위 클래스로 추상 인터페이스를 정의
  - 최상위 기능계층
  - 기본 기능들만 정의
- RefinedAbstraction
  - Abstraction 에 의해 정의된 인터터페이스를 확장 extends
  - 기능 계층에서 새로운 부분을 확장한 하위 클래스
  - 기능 클래스의 기능을 추가함
- Implementor
  - 구현 클래스의 최상위 클래스
  - 구현 클래스를 위한 인터페이스
- ConcreteImplementor
  - Implementor 인터페이스를 구현, 실제 기능 구현
  - 구체적인 구현자

# 활용성

- 추상적 개념과 이에 대한 구현 사이의 지속적인 종속 관계를 피하고 싶을 때
  - 런타임에 구현 방법을 선택하거나 구현 내용을 변경하고 싶을 떄
- 추상적 개념과 구현 모두가 독립적으로 서브 클래싱을 통해 확장되어야 할 떄
- 추상적 개념에 대한 구현 내용을 변경하는 것이 다른 관련 프로그램에 영향을 주지 않을 때

# 예시

- Abstraction
  - `AutoPilot`
- RefinedAbstraction
  - `A380AutoPilot`
  - `Boeing747AutoPilot`
- Implementor
  - `AirplaneControlMechanism`
- ConcreteImplementor
  - `A380ControlMachanism`
  - `Boeing747ControlMachanism`

# 브리지 패턴 vs 어댑터 패턴

- 공통점
  - 인터페이스의 세부 내용을 감춤
- 차이점
  - 어댑터 패턴 : 이미 완성된 라이브러리나 프레임워크에 확장성을 지원하기 위함
    - 서로 관련없는 클래스들이 함께 동작 하도록 함
  - 브리지 패턴 : 확장성을 고려하는 설계에 사용
    - 프로젝스 설계 단계 초기에 투입됨
