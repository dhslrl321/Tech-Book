# 싱글턴 패턴

- 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근을 제공
  - DBConnectionPool, ThreadPool 과 같음
  - 최초에 한 번만 메모리에 할당
  - 인스턴스를 사용할 때 똑같은 인스턴스를 만드는 것이 아니라 동일한 인스턴스를 사용하게 함
- 동일한 일을 수행하는 여러 인스턴스를 만들면 자원을 낭비하거나 버그를 발생시킬 수 있음
- 인스턴스가 유일함을 보장해야 함
  - 하나의 인스턴스만을 유지하기 위해서 인스턴스 생성에 제약을 둠
    - new 를 실행할 수 없도록 private 설정
- 단일 객체를 참조할 정적 참조 변수가 필요

# 장점

- 고정된 메모리 영역을 얻음
  - 최초 한 번의 new 로 인스턴스를 사용해서 메모리 낭비 방지
- 전역 인스턴스이기 때문에 다른 클래스의 인스턴스들이 데이터를 공유하기 쉬움
- 두 번째 이용시에 객체 로딩 시간이 줄어들어 성능상 이점
- 스프링에서 사용하는 이유는 DI 컨테이너에 요청할 때 마다 새로운 객체를 생성하는데, 여기서 많은 트래픽이 있는 서비스라면 메모리 낭비가 심하게 변함

# 단점

- 싱글톤 인스턴스가 너무 많은 일을 수행함
  - 많은 데이터를 공유할 때 다른 클래스간의 결합도가 높아짐
- 객체지향의 개방 폐쇠 원칙을 위해밤
  - 수정과 테스트가 어려워짐
- 멀티쓰레드 환경에서 동기화 처리를 하지 않으면 인스턴스가 여러개 생성될 수 있음
  - `synchronized`를 이용해서 이 문제를 해결할 수 있음
  - `synchronized` 특성상 큰 성능저하가 우려됨
  - 물론 이 문제도 Double-Checked Locking과 Thread safe lazy Initialization을 이용해서 해결할 수 있음
    - 하지만 난 못함

# 참여 객체

- SingleTon
  - `static instance()` 를 제공해서 유일한 인스턴스로 접근할 수 있도록 함

# 예제

- 여러 비행기가 하나의 관제탑으로 요청을 보내야 함
- 그래서 관제탐을 싱클턴으로 관리
- 각각의 비행기가 보내는 서로 다른 요청은 하나의 관제탑으로 요청됨
- 참여 객체
  - SingleTon
    - `ControlTower`

# 내 생각

- 사실 singleton은 안티패턴이라고 함
  - 전역이라 상태를 확인하기 힘들어서 테스트 및 디버깅이 힘듦
  - 싱글톤 코드로 인해 단단한 결합이 형성
    - 개방 폐쇠 원칙 위배
  - 코드가 복잡해서 디자인의 흐름을 깨트림
