# 처리율 제한 장치

키워드 : `Rate Limit`, `Redis Rate Limit`, `BitBucket`, `Fixed-Sliding-Window`, `Sliding-Window`

### 목차

- 처리율 제한 장치
  - Rate Limiter 란
  - 사용 예제
  - 장점
  - 구현 방법
- Rate Limit 구현 알고리즘
  - Token Bucket
  - Leaky Bucket
  - Fixed-Window-Counter
  - Sliding-Window-Log
  - Sliding-Window-Counter

# 처리율 제한 장치

- **처리율 제한 장치, Rate Limiter란?**
  - 네트워크 트래픽을 제어하는 어떠한 장치 (꼭 웹에만 국한된 개념은 아님)
  - HTTP 에서는 특정 조건 (기한, 횟수) 에 의해서 사용자의 요청을 잠시 중단시키는 것을 의미한다.
  - 사용자에게 안정적인 서비스를 제공하기 위해서 처리양을 제한하여 지속적인 서비스를 할 수 있도록 하는 장치
- **사용 예제**
  - 한 사용자는 10분동안 5개 이상의 글을 작성할 수 없다.
  - 같은 디바이스로 하루에 1번만 리워드를 받을 수 있다.
  - 전체 시스템은 요청을 초당 100개만 받을 수 있다.
  - 서비스 내부에서 외부 벤더에게 보낼 수 있는 요청은 하루에 10개로 제한한다.
- **장점**
  - DoS 를 방지할 수 있다.
  - 비용을 절감할 수 있다.
  - 서버의 과부하를 막을 수 있다.
- **구현 방법 혹은 제약사항**
  - 위치
    - 애플리케이션 코드 내부
    - Middleware 로서 독립적인 서버 및 Gateway 에 부착
      - Rate Limiter 는 구현이 까다로우니 상용 API Gateway 에 있는 처리율 제한 장치를 사용하는 것도 방법임
  - 제약
    - 한 시스템 내부에서 여러 컴포넌트들이 처리율 제한 장치를 사용할 수 있어야 해야한다.
    - 처리율 제한 규칙을 부착할 수 있도록 해야한다.
    - 낮은 응답 시간을 보장해 다른 서비스에 영향을 가지 않도록 해야한다.

# Rate Limit 구현 알고리즘

- **Token Bucket 알고리즘**
  - 원리
    - Bucket 에 일정 양의 Token 을 추가
      - 이 Token 은 초당 몇개씩 혹은 시간당 혹은 하루에 몇개씩으로 고정되고 공급될 수 있음
    - 요청 하나당 Token 하나를 점유하고 요청을 전달
    - 만약 Bucket 안에 Token 이 비어있다면 요청을 처리하지 않음
      - 요청을 처리하지 않고 버리거나 따로 큐에 담아놓을 수 있음
  - 장점
    - 구현이 쉬움
    - 메모리 사용 측면에서 좋음
    - 짧은 시간에 집중되는 트래픽도 처리 가능 (버킷에 토큰만 있으면 서버로 전달이 가능하니까)
  - 단점
    - Bucket 크기와 Token 의 양을 적절히 맞추는 일이 힘듦
  - 기타
    - 만약 시스템이 초당 10000개의 요청을 처리할 수 있다면?
      - 하나의 버킷을 두고 토큰을 1초 간격으로 10000개로 생성하면 됨
- **Leaky Bucket 알고리즘**
  - 원리
    - Queue 를 이용하여 구현함
    - 요청이 들어오면 Queue 에 추가
      - 만약 큐가 가득 차있다면 해당 요청을 버림 (혹은 다른 큐에 담아놓을 수 있겠지)
    - 일정 시간마다 Queue 에서 데이터를 꺼내서 요청을 처리
  - 장점
    - 큐의 크기가 제한되어 있어서 메모리 사용 예측이 용이
    - 일정 시간동안 큐에서 일정량의 데이터를 꺼내오기 때문에 안정적인 처리가 가능
      - 고정된 처리율로 인해 안정적 출력 (Stable Overflow Rate) 이 필요한 곳에 적합
  - 단점
    - 단시간에 트래픽이 몰리면 큐에 오래된 요청들이 쌓이게 되고 최신 요청들은 버려지게 됨
- **Fixed Window Counter 알고리즘**
  - 원리
    - 타임라인을 두고 타임라인간 일졍한 간격으로 window 를 나눔
    - 각 window 마다 카운터를 붙임
    - 요청이 올 때마다 카운터 값을 1씩 증가
    - 만약 요청이 미리 지정된 Threshold 를 넘긴다면 요청을 버림
      - 새로운 Window 가 열릴 때 까지 요청들은 버려짐
  - 장점
    - 메모리 효율이 좋음
    - window 가 닫히는 시점에 카운터를 초기화 시키는 원리이므로 이에 적절한 상황에 좋음
  - 단점
    - window 경계 부분에서 트래픽이 한 번에 몰릴 수 있음
    - 그럼 시스템의 처리 한도보다 더 많은 양을 처리하게 될 수 있음
- **Sliding Window Log 알고리즘**
  - 지금 이해하기에는 어려움
- **Sliding Window Counter 알고리즘**
  - 역시 지금 이해하기에는 어려움
